# Модули

- hashlib
  - `hash_object = hashlib.md5(stri.encode())`
  - `hash = hash_object.hexdigest()  # 'bb649c83dd1ea5c9d9dec9a18df0ffe9'`
- tkinter 
  - <https://docs.python.org/3/library/tkinter.html>
  - встановлення: `sudo apt install python3-tk`
  - перевірка: `python3 -m tkinter`

---

# getpass

```python
import getpass

while 1:
  passw1 = getpass.getpass()
  passw2 = getpass.getpass('Please, enter your password again: ')

  if passw1 == passw2:
    print(f'Password "{passw1}" saved. Thank you!')
    break
  else:
    print(f'Sorry, your passwords are incorrect: "{passw1}" vs "{passw2}".')
    yn = input('Try again? (y/n): ')
    if yn == 'y':
      print()
      continue
    else:
      break

print('Good bye!')
```


```python
from sys import *
```
Такая конструкция позволяет подключить _почти все_ атрибуты (переменные и функции) из модуля. <span class="info">i</span> Если в модуле определена переменная `__all__` (список атрибутов, которые могут быть подключены), то будут подключены только атрибуты из этого списка. Если переменная `__all__` не определена, то будут подключены все атрибуты, _не начинающиеся с нижнего подчеркивания_.

Необходимо учитывать, что импортирование всех атрибутов из модуля может нарушить пространство имен главной программы, так как переменные, имеющие одинаковые имена, будут перезаписаны.

---

## Иерархия подключения модулей

Очень много и запутанно написано {% include a.htm url='https://tproger.ru/translations/guide-into-python-imports/' text='здесь' %}, загляни, на свежую голову...

---

Чтобы увидеть содержимое sys.path, можно сделать так:

```python
import sys
print(sys.path)
# или еще лучше так:
for item in sys.path:
    print(item)
```

## Исполняемый модуль

Если кроме функций, констант и переменных в модуле прописаны и команды вне функций, то при импортировании модуля весь этот код выполнится (как обычный скрипт), при этом, все атрибуты модуля будут импортироваться (как библиотека).

Чтобы код такого модуля не выполнялся при импортировании, а отрабатывал только при запуске модуля, как скрипта - его необходимо правильно оформить.

- весь исполняемый код помещается в функцию main().
- функция main() вызывается после условия:

```python
if __name__ == '__main__':
    main()
```

В этом случае при импортировании интерпретатор Python не будет запускать код, вложенный в условие, но все функции библиотеки можно будет использовать.

<span class="ques">?</span> А будет ли импортироваться сама фунция `main()`?



## `__all__` Управление импортом модулей из пакета.

https://docs-python.ru/tutorial/sistema-importa-python/peremennaja-all-paketah-moduljah/

```
В материале "Инструкция from <modulle> import <names>" рассматривался случай использования конструкции from <module> import *, когда все объекты модуля импортируются в область видимости вызывающей стороны, за исключением тех, чьи имена начинаются с символа подчеркивания.

Аналогичное утверждение для пакета выглядит следующим образом from <package> import *. Попробуем сделать импорт всех модулей пакета из примера материала "Инициализация пакета с модулями":

>>> dir()
# ['__annotations__', '__builtins__', '__doc__', '__loader__', 
# '__name__', '__package__', '__spec__']

>>> from pkg import *
>>> dir()
# ['__annotations__', '__builtins__', '__doc__', '__loader__', 
# '__name__', '__package__', '__spec__']

По умолчанию инструкция from <package> import * ничего не импортирует.

Python следует соглашению: если __init__.py файл в каталоге пакета содержит список с именем __all__, он считается списком модулей, которые должны быть импортированы при обнаружении инструкции from <package> import *.

Изменим __init__.py в каталоге pkg следующим образом:

__all__ = [
        'mod1',
        'mod2'
        ]
var_init = ['one', 'two', 'three']

Попробуем сделать импорт всех модулей пакета pkg еще раз.

>>> from pkg import *
>>> dir()
# ['__annotations__', '__builtins__', '__doc__', '__loader__',
# '__name__', '__package__', '__spec__', 'mod1', 'mod2']

>>> mod2.bar()
# Модуль 2, функция bar()
>>> mod1.foo()
# Модуль 1, функция foo(), var_init = ['one', 'two', 'three']

Использование конструкции import * не считается хорошей практикой, как для пакетов, так и для модулей. Переменная __all__ дает некоторый контроль над тем, что происходит, когда указана конструкция import *.

Кстати, __all__ также может быть определена в модуле и служит той же цели: контролировать то, что импортируется с помощью конструкции import *.

Изменим mod1.py следующим образом:

__all__ = ['foo']

def foo():
    from pkg import var_init
    print('Модуль 1, функция foo())

def other():
    print('Модуль 1, функция other())

Теперь конструкция from pkg.mod1 import * будет импортировать только то, что содержится в __all__:

>>> from pkg.mod1 import *
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__',
'__package__', '__spec__', 'foo']

>>> foo()
# Модуль 1, функция foo()

>>> other()
# Traceback (most recent call last):
# ...
# NameError: name 'other' is not defined

Функция foo() теперь определена в локальном пространстве имен, а функция other() - нет, потому что не находится в списке __all__.

Таким образом, переменная __all__ используется как пакетами, так и модулями для управления тем, что импортируется при использовании конструкции import *. Но поведение по умолчанию отличается:

    Для пакета, когда __all__ не определен, import * ничего не импортирует.
    Для модуля, когда __all__ не определен, import * импортирует все, кроме имен, начинающихся с символа подчеркивания.
```
