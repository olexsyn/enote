# Словари (dict)

см.: <https://webdevblog.ru/kak-perebrat-slovar-v-python/>

## Создание пустого словаря:

```python
dict_sample1 = {}
dict_sample2 = dict()
```

## Создание словаря с данными:

Cловарь, где ключи являются целыми числами:

```python
dict_sample = {
    1: 'mango',
    2: 'banana'
}
```
Создание словаря с ключами разных типов:

```python
dict_sample = {
    'fruit': 'mango', 
    1: [4, 6, 8]
}
```

Можно также создать словарь, явно вызвав метод dict():

```python
dict_sample = dict(
    'one':'mango', 
    'two':'banana'
)
```
Чтобы код выглядел читабельней в dict() можно не использовать кавычки со строковыми ключами, но `:` при этом, нужно заменить знаком `=`:

```python
dict_sample = dict(
    one = 'mango',
    two = 'banana',  # у последней пары может стоять запятая
)
```

Словарь можно создать с помощью последовательности:

```python
dict_sample = dict(
    [(1,'mango'), (2,'banana')]
)
```

Словари могут быть вложенными. Это значит, что можно создавать словари внутри существующего словаря. Например:

```python
dict_sample = {
    1: {'student1': 'Nicholas', 'student2': 'John', 'student3': 'Mercy'}, 
    2: {'course1': 'Computer Science', 'course2': 'Mathematics', 'course3': 'Accounting'}
}
```

## Перебор словаря

```python
for k, v in dict_sample.items():
    print(k, '>', v)
```
```
one > mango
two > banana
```

## Перебор словаря по ключам

```python
for key in dict_sample.keys():
    print(key, '>', dict_sample[key])
```
```
one > mango
two > banana
```
## Перебор значений словаря

```python
for i in dict_sample.values():
    print(i)
```
```
mango
banana
```

## Поэлементное изменение словаря

https://ru.hexlet.io/courses/python-dicts/lessons/updating/theory_unit

Словарь в Пайтоне — изменяемый (мутабельный). Однако для добавления новой пары ключ-значение не нужны отдельные методы, вроде спискового метода .append — достаточно обычного присваивания:

```
>>> d = {}  # пустой словарь
>>> d["a"] = 100
>>> d
{'a': 100}
>>> d["b"] = 200
>>> d["a"] = 0
>>> d
{'a': 0, 'b': 200}
```

Здесь вы можете увидеть, что присваивание значения новому ключу выглядит точно так же, как и присваивание существующему. Удобно!

## Удаление элементов

из словаря делается с помощью метода pop — в этом словарь уже больше похож на список. Только вместо индекса используется ключ:

```
>>> d = {'a': 1, 'b': 2}
>>> d.pop('a')
1
>>> d
{'b': 2}
>>> d.pop('BANG')
...
KeyError: 'BANG'
```

Пример показывает, что если попытаться извлечь значение по несуществующему ключу, то будет возбуждено исключение. Однако метод pop можно вызывать с указанием значения по умолчанию. В этом случае при отсутствии ключа в словаре будет возвращено это самое значение, а исключение возбуждено не будет. Пример:

```
>>> d = {'a': 1, 'b': 2}
>>> d.pop('BANG', None)
>>> d.pop('BANG', 42)
42
```

Аналогом спискового pop без аргументов для словаря служит метод popitem. Этот метод извлекает ключ и значение в виде кортежа, а если словарь уже пуст, то возбуждает исключение:

```
>>> d = {'a': 1}
>>> d.popitem()
('a', 1)
>>> d.popitem()
...
KeyError: 'popitem(): dictionary is empty'
```

Помним, что порядок ключей в словаре не зависит от того, в какой последовательности эти ключи добавлялись в словарь. Поэтому мы не можем полагаться на то, в каком порядке будут возвращаться пары при вызове popitem! Но в том, что все пары будут извлечены и каждая пара будет извлечена строго один раз, мы можем быть уверены :)

## Дополнение одного словаря другим

У списка есть метод extend, который расширяет один список другим. У словаря есть похожий по смыслу метод update. Однако, при вызове update ассоциированный объект словаря не просто получает пары ключ-значение из нового словаря. Происходит именно обновление данных (поэтому метод и называется update): новые ключи дописываются в словарь, а если какие-то ключи уже существовали до этого, то значения, с ними связанные, будут заменены новыми. 
Пример:

```
>>> cart = {'apples': 2, 'oranges': 1}
>>> addon = {'oranges': 5, 'lemons': 3}
>>> cart.update(addon)
>>> cart
{'apples': 2, 'oranges': 5, 'lemons': 3}
```

Лимоны были добавлены, а количество апельсинов было обновлено. Просто, понятно, удобно.

## Копирование словаря

В случае списков мы можем сложить два списка и получить новый. Или же получить копию одного списка и уже её дополнить данными из второго. Но словари нельзя складывать и срезы словари тоже не поддерживают. Зато у словаря есть метод copy, который работает аналогично копированию списка с помощью среза [:] — при вызове он возвращает так называемую поверхностную копию (она же "неглубокая копия", "shallow copy") словаря. Поверхностная копия воспроизводит только структуру словаря, но не копирует значения, а только лишь создаёт на них новые ссылки. И тем не менее поверхностная копия — новый словарь, который может изменять свой состав, не влияя на оригинал:

```
>>> d = {'a': 1, 'b': [42]}
>>> c = d.copy()
>>> c.update({'a': 10, '1k': 1024})
>>> c
{'a': 10, 'b': [42], '1k': 1024}
>>> c['b'].append(None)
>>> c
{'a': 10, 'b': [42, None], '1k': 1024}
>>> d
{'a': 1, 'b': [42, None]}
```

Словарь c получил свою собственную структуру и его обновление не затронуло оригинальный словарь d. Однако изменение объекта списка по ссылке затронуло и оригинал, потому что при копировании словаря ссылка на список тоже скопировалась!

## Очистка словаря

Списки мы можем очистить с помощью присваивания срезу (l[:] = []). В случае словаря вместо присваивания срезу используется метод clear:

```
>>> d = {'a': 1}
>>> d.clear()
>>> d
{}
```

### Перегорнути словник

```python
ip_dict = dict(
    '1.2.3.4' = 'server_1',
    '2.3.4.5' = 'server_2',
)
ip_dict = {v:k for k,v in ip_dict.items()}

print(ip_dict)
```
_output:_
```
{'server_1':'1.2.3.4','server_2':'2.3.4.5',}
```

---

<a name="create"></a>
{% include_relative create.md %}

<a name="access"></a>
{# include_relative access.md #}

